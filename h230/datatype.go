// Code generated by "hl7fetch -pkgdir h230 -root ./genjson -version 2.3 -network"; DO NOT EDIT.

package h230

import "time"

// Address
//
// Example:
// |10 ASH LN^#3^LIMA^OH^48132|
type AD struct {
	HL7                        HL7Name `hl7:",name=AD,len=0,type=d"`
	StreetAddress              ST      `hl7:"1,display=Street address "`
	OtherDesignation           ST      `hl7:"2,display=Second line of address. In general- it qualifies address.  Examples:  Suite 555 or Fourth Floor"`
	City                       ST      `hl7:"3,display=City"`
	StateOrProvince            ST      `hl7:"4,display=State or province should be represented by the official postal service codes for that country"`
	ZipOrPostalCode            ST      `hl7:"5,display=Zip or postal codes should be represented by the official codes for that country.  In the US- the zip code takes the form 99999[-9999]- while the Canadian postal code takes the form A9A-9A9"`
	Country                    ID      `hl7:"6,table=ISO3166,display=Defines  the country of the address.   ISO 3166 provides a list of country codes that may be used"`
	AddressType                ID      `hl7:"7,table=0190,display=Type is optional and defined by HL7 table 0190 - Address type"`
	OtherGeographicDesignation ST      `hl7:"8,display=Other geographic designation includes county- bioregion- SMSA- etc"`
}

// Coded Element
//
// This data type transmits codes and the text associated with the code.  To allow all six components of a CE data type to be valued,
// the maximum length of this data type must be at  least 60 (see Section 2.6.2, “Maximum length”)
//
// Example:
// |F-11380^CREATININE^I9^2148-5^CREATININE^LN|
type CE struct {
	HL7                         HL7Name `hl7:",name=CE,len=0,type=d"`
	Identifier                  ST      `hl7:"1,display=Sequence of characters (the code) that uniquely identifies the item being referenced by the <text>.  Different coding schemes will have different elements here"`
	Text                        ST      `hl7:"2,display=Name or description of the item in question.  E.g.- myocardial infarction or X-ray impression.  Its data type is string (ST). "`
	NameOfCodingSystem          ST      `hl7:"3,display=Each coding system is assigned a unique identifier.  This component will serve to identify the coding scheme being used in the identifier component.  The combination of the identifier and name of coding system components will be a unique code for a data item  Each system has a unique identifier. ASTM E123894- Diagnostic- procedure- observation- drug ID- and health outcomes coding systems are identified in the tables in Section 7.1.4- “Coding schemes.”  Others may be added as needed.  When an HL7 table is used for a CE data type- the name of coding system component is defined as HL7nnnn where nnnn is the HL7 table number."`
	AlternateIdentifier         ST      `hl7:"4,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally-defined system"`
	AlternateText               ST      `hl7:"5,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally-defined system"`
	NameOfAlternateCodingSystem ST      `hl7:"6,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally-defined system"`
}

// Composite ID With Check Digit
//
// This data type is used for certain fields that commonly contain check digits, e.g., PID-3-patient ID (internal).  If a site
// is not using check digits for a particular CK field, the second and third components are not valued.
//
// Example:
// |128952^6^M11^ADT01|
type CK struct {
	HL7                                        HL7Name `hl7:",name=CK,len=0,type=d"`
	IDNumber                                   NM      `hl7:"1,display=ID Number"`
	CheckDigit                                 ST      `hl7:"2,display=The check digit in this data type is not an add-on produced by the message processor.  It is the check digit that is part of the identifying number used in the sending application.  If the sending application does not include a self-generated check digit in the identifying number- this component should be valued null"`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"3,table=0061,display=The check digit scheme codes are defined in HL7 table 0061 - Check digit scheme"`
	AssigningAuthority                         *HD     `hl7:"4,display=The assigning authority is a unique name of the system that creates the data.  It is an HD data type.  It is equivalent to the application ID of the placer or filler order number (see Chapter 4).  Assigning authorities are unique across a given HL7 implementation"`
}

// Absolute Range
type CM_ABS_RANGE struct {
	HL7              HL7Name   `hl7:",name=CM_ABS_RANGE,len=0,type=d"`
	Range            *CM_RANGE `hl7:"1,display=Range"`
	NumericChange    NM        `hl7:"2,display=Numeric Change"`
	PercentPerChange NM        `hl7:"3,display=Percent Per Change"`
	Days             NM        `hl7:"4,display=Days"`
}

// Authorization Information
type CM_AUI struct {
	HL7                 HL7Name `hl7:",name=CM_AUI,len=0,type=d"`
	AuthorizationNumber ST      `hl7:"1,display=Authorization Number"`
	Date                DT      `hl7:"2,format=YMD,display=Date"`
	Source              ST      `hl7:"3,display=Source"`
}

// Charge Time
type CM_CCD struct {
	HL7              HL7Name `hl7:",name=CM_CCD,len=0,type=d"`
	WhenToChargeCode ID      `hl7:"1,table=0100,display=When To Charge Code"`
	DateTime         TS      `hl7:"2,format=YMDHMS,display=Date/time"`
}

// Daily Deductible
type CM_DDI struct {
	HL7          HL7Name `hl7:",name=CM_DDI,len=0,type=d"`
	DelayDays    NM      `hl7:"1,display=Delay Days"`
	Amount       NM      `hl7:"2,display=Amount"`
	NumberOfDays NM      `hl7:"3,display=Number Of Days"`
}

// Activation Date
type CM_DIN struct {
	HL7             HL7Name `hl7:",name=CM_DIN,len=0,type=d"`
	Date            TS      `hl7:"1,format=YMDHMS,display=Date"`
	InstitutionName *CE     `hl7:"2,display=Institution Name"`
}

// Discharge Location
type CM_DLD struct {
	HL7               HL7Name `hl7:",name=CM_DLD,len=0,type=d"`
	DischargeLocation ID      `hl7:"1,table=0113,display=Discharge Location"`
	EffectiveDate     TS      `hl7:"2,format=YMDHMS,display=Effective Date"`
}

// Delta Check
type CM_DLT struct {
	HL7              HL7Name   `hl7:",name=CM_DLT,len=0,type=d"`
	Range            *CM_RANGE `hl7:"1,display=The range to which the following applies: <low & high>.  All the ranges are defined in terms of the customary reporting units given in OM2-3-units of measure.  If no value range is given- the check applies to all values"`
	NumericThreshold NM        `hl7:"2,display=The numeric threshold of the change that is detected- e.g.- 10. "`
	Change           ST        `hl7:"3,display=Whether the change is computed as a percent change or an absolute change.  This component can have two possible values:      % Indicates a percent change      a  Absolute change "`
	LengthOfTimeDays NM        `hl7:"4,display=The length of time that the service retains a value for computing delta checks.  This is recorded in number of days"`
}

// Day Type And Number
type CM_DTN struct {
	HL7          HL7Name `hl7:",name=CM_DTN,len=0,type=d"`
	DayType      IS      `hl7:"1,table=0149,display=Day Type"`
	NumberOfDays NM      `hl7:"2,display=Number Of Days"`
}

// Parent Order
type CM_EIP struct {
	HL7                      HL7Name `hl7:",name=CM_EIP,len=0,type=d"`
	ParentSPlacerOrderNumber *EI     `hl7:"1,display=Parent s Placer Order Number"`
	ParentSFillerOrderNumber *EI     `hl7:"2,display=Parent s Filler Order Number"`
}

// Error
type CM_ELD struct {
	HL7                  HL7Name `hl7:",name=CM_ELD,len=0,type=d"`
	SegmentID            ST      `hl7:"1,display=Segment ID"`
	Sequence             NM      `hl7:"2,display=Sequence"`
	FieldPosition        NM      `hl7:"3,display=Field Position"`
	CodeIdentifyingError *CE     `hl7:"4,display=Code Identifying Error"`
}

// Charge To Practise
type CM_MOC struct {
	HL7          HL7Name `hl7:",name=CM_MOC,len=0,type=d"`
	DollarAmount *MO     `hl7:"1,display=Dollar Amount"`
	ChargeCode   *CE     `hl7:"2,display=Charge Code"`
}

// Message Type
//
// This field contains the message type and trigger event for the message.
type CM_MSG struct {
	HL7          HL7Name `hl7:",name=CM_MSG,len=0,type=d"`
	MessageType  ID      `hl7:"1,table=0076,display=The first component is the message type edited by HL7 table 0076 - Message type"`
	TriggerEvent ID      `hl7:"2,table=0003,display=The second is the trigger event code edited by HL7 table 0003 - Event type."`
}

func (d CM_MSG) MessageStructureID() string {
	if len(d.TriggerEvent) == 0 {
		return d.MessageType
	}
	return d.MessageType + "_" + d.TriggerEvent
}

// Observing Practitioner
type CM_NDL struct {
	HL7                HL7Name `hl7:",name=CM_NDL,len=0,type=d"`
	OPName             *CN     `hl7:"1,display=OP Name"`
	StartDateTime      TS      `hl7:"2,format=YMDHMS,display=Start Date/time"`
	EndDateTime        TS      `hl7:"3,format=YMDHMS,display=End Date/time"`
	PointOfCare        IS      `hl7:"4,table=0302,display=Point Of Care"`
	Room               IS      `hl7:"5,table=0303,display=Room"`
	Bed                IS      `hl7:"6,table=0304,display=Bed"`
	Facility           *HD     `hl7:"7,display=Facility"`
	LocationStatus     IS      `hl7:"8,table=0306,display=Location Status"`
	PersonLocationType IS      `hl7:"9,table=0305,display=Person Location Type"`
	Building           IS      `hl7:"10,table=0307,display=Building"`
	Floor              ST      `hl7:"11,display=Floor"`
}

// Occurence
type CM_OCD struct {
	HL7            HL7Name `hl7:",name=CM_OCD,len=0,type=d"`
	OccurrenceCode *CE     `hl7:"1,display=Occurrence Code"`
	OccurrenceDate DT      `hl7:"2,format=YMD,display=Occurrence Date"`
}

// Order Sequence
//
// There are many situations, such as the creation of an order for a group of intravenous (IV) solutions, where the sequence
// of the individual intravenous solutions (each a service in itself) needs to be specified, e.g., hyperalimentation with
// multi-vitamins in every third bottle.
//
// There are other situations where part of the order’s instructions contains a results condition of some type, such as “PRN
// pain.”  There is currently a free text “condition” component of ORC-7-quantity/timing which allows any condition to be
// specified.  However, to support a fully encoded version of order sequencing, or results condition, we have defined in the
// following paragraphs a 10th component of ORC-7quantity/timing.
//
// The sequencing conditions supported by this 10th component are based on the completion of a  predecessor service.
type CM_OSD struct {
	HL7                               HL7Name `hl7:",name=CM_OSD,len=0,type=d"`
	SequenceResultsFlag               ID      `hl7:"1,table=OSD1,display=S for sequence conditions; C for cyclical; R is reserved for possible future use. The C will be used for indicating a repeating cycle of orders; for example- individual intravenous solutions used in a cyclical sequence (a.k.a. “Alternating IVs”).  This value would be compatible with linking separate orders or with having all cyclical order components in a single order.  Likewise- the value would be compatible with either Parent-Child messages or a single order message to communicate the orders’ sequencin"`
	PlacerOrderNumberEntityIdentifier ST      `hl7:"2,required,display=Contains the first two components of the placer order number: entity identifier (ST) and namespace ID (IS) (respectively).  Uses two subcomponents since the placer order number is an EI data type.  We have not defined subsubcomponents in HL"`
	PlacerOrderNumberNamespaceID      IS      `hl7:"3,display=Contains the first two components of the placer order number: entity identifier (ST) and namespace ID (IS) (respectively).  Uses two subcomponents since the placer order number is an EI data type.  We have not defined subsubcomponents in HL"`
	FillerOrderNumberEntityIdentifier ST      `hl7:"4,required,display=Contains the first two components of the filler order number: entity identifier (ST) and namespace ID (IS) (respectively).  Uses two subcomponents since the filler order number is an EI data type.  We have not defined subsubcomponents in HL7."`
	FillerOrderNumberNamespaceID      IS      `hl7:"5,display=Contains the first two components of the filler order number: entity identifier (ST) and namespace ID (IS) (respectively).  Uses two subcomponents since the filler order number is an EI data type.  We have not defined subsubcomponents in HL7."`
	SequenceConditionValue            ST      `hl7:"6,display=The acceptable condition values have the form commonly used in project planning methodologies: <one of “SS”- “EE”- “SE”- or “ES”> +/- <time>   The first letter stands for start (S) or end (E) of predecessor order- where the predecessor is defined by the placer or filler order number in subcomponents 1-2 or subcomponents 3-4.   The second letter stands for the start (S) or end (E) of the successor order- where the successor order is the order containing this quantity/timing specification.   The time specifies the interval between the predecessor and successor starts or ends (see following examples). Where <time> is defined as:     - S<integer> do for <integer> seconds    - M<integer> do for <integer> minutes    - H<integer> do for <integer> hours    - D<integer> do for <integer> days    - W<integer> do for <integer> weeks    - L<integer> do for <integer> months"`
	MaximumNumberOfRepeats            NM      `hl7:"7,display=The maximum number of repeats to be used only on cyclic groups.  The total number of repeats is constrained by the end date/time of the last repeat or the end date/time of the parent- whichever is first."`
	PlacerOrderNumberUniversalID      ST      `hl7:"8,required,display=Contains the last two components of the placer order number: universal ID (ST) and universal ID type (ID) (respectively).  Uses two subcomponents since the placer order number is an EI data type.  We have not defined subsubcomponents in HL7."`
	PlacerOrderNumberUniversalIDType  ID      `hl7:"9,display=Contains the last two components of the placer order number: universal ID (ST) and universal ID type (ID) (respectively).  Uses two subcomponents since the placer order number is an EI data type.  We have not defined subsubcomponents in HL7."`
	FillerOrderNumberUniversalID      ST      `hl7:"10,required,display=Contains the last two components of the filler order number: universal ID (ST) and universal ID type (ID) (respectively).  Uses two subcomponents since the filler order number is an EI data type.  We have not defined subsubcomponents in HL7"`
	FillerOrderNumberUniversalIDType  ID      `hl7:"11,display=Contains the last two components of the filler order number: universal ID (ST) and universal ID type (ID) (respectively).  Uses two subcomponents since the filler order number is an EI data type.  We have not defined subsubcomponents in HL7"`
}

// Occurence Span
type CM_OSP struct {
	HL7                     HL7Name `hl7:",name=CM_OSP,len=0,type=d"`
	OccurrenceSpanCode      *CE     `hl7:"1,display=Occurrence Span Code"`
	OccurrenceSpanStartDate DT      `hl7:"2,format=YMD,display=Occurrence Span Start Date"`
	OccurrenceSpanStopDate  DT      `hl7:"3,format=YMD,display=Occurrence Span Stop Date"`
}

// Pre-certification Required
//
// This field indicates whether pre-certification is required for particular patient types, and the time window for obtaining
// the certification.
type CM_PCF struct {
	HL7                         HL7Name `hl7:",name=CM_PCF,len=0,type=d"`
	PreCertificationPatientType IS      `hl7:"1,table=0150,display=pre-certification patient type refers to user-defined table 0150 - Pre-certification patient type for suggested values "`
	PreCertificationRequired    ID      `hl7:"2,table=0136,display=pre-certification required refers to HL7 table 0136 - Yes/no indicator for valid values "`
	PreCertificationWindwow     TS      `hl7:"3,format=YMDHMS,display=Pre-certification Windwow"`
}

// Penalty
type CM_PEN struct {
	HL7           HL7Name `hl7:",name=CM_PEN,len=0,type=d"`
	PenaltyType   IS      `hl7:"1,table=0148,display=Penalty Type"`
	PenaltyAmount NM      `hl7:"2,display=Penalty Amount"`
}

// Person Identifier
type CM_PI struct {
	HL7                 HL7Name `hl7:",name=CM_PI,len=0,type=d"`
	IDNumber            ST      `hl7:"1,display=ID Number"`
	TypeOfIDNumber      IS      `hl7:"2,display=Type Of ID Number"`
	OtherQualifyingInfo ST      `hl7:"3,display=Other Qualifying Info"`
}

// Privileges
type CM_PIP struct {
	HL7            HL7Name `hl7:",name=CM_PIP,len=0,type=d"`
	Privilege      *CE     `hl7:"1,display=Privilege"`
	PrivilegeClass *CE     `hl7:"2,display=Privilege Class"`
	ExpirationDate DT      `hl7:"3,format=YMD,display=Expiration Date"`
	ActivationDate DT      `hl7:"4,format=YMD,display=Activation Date"`
}

// Practitioner ID Numbers
type CM_PLN struct {
	HL7                      HL7Name `hl7:",name=CM_PLN,len=0,type=d"`
	IDNumber                 ST      `hl7:"1,display=ID Number"`
	TypeOfIDNumber           IS      `hl7:"2,table=0338,display=Type Of ID Number"`
	StateOtherQualifyingInfo ST      `hl7:"3,display=State/other Qualifying Info"`
	ExpirationDate           DT      `hl7:"4,format=YMD,display=Expiration Date"`
}

// Parent Result Link
type CM_PRL struct {
	HL7                                     HL7Name `hl7:",name=CM_PRL,len=0,type=d"`
	OBX3ObservationIdentifierOfParentResult *CE     `hl7:"1,display=OBX-3 Observation Identifier Of Parent Result"`
	OBX4SubIDOfParentResult                 ST      `hl7:"2,display=OBX-4 Sub-ID Of Parent Result"`
	PartOfOBX5ObservationResultFromParent   TX      `hl7:"3,display=Part Of OBX-5 Observation Result From Parent"`
}

// Policy Type
type CM_PTA struct {
	HL7         HL7Name `hl7:",name=CM_PTA,len=0,type=d"`
	PolicyType  IS      `hl7:"1,table=0147,display=Policy Type"`
	AmountClass IS      `hl7:"2,table=0193,display=Amount Class"`
	Amount      NM      `hl7:"3,display=Amount"`
}

// Wertebereich
type CM_RANGE struct {
	HL7       HL7Name `hl7:",name=CM_RANGE,len=0,type=d"`
	LowValue  ST      `hl7:"1,display=Low Value"`
	HighValue ST      `hl7:"2,display=High Value"`
}

// Reference Range
type CM_RFR struct {
	HL7            HL7Name   `hl7:",name=CM_RFR,len=0,type=d"`
	ReferenceRange *CM_RANGE `hl7:"1,display=This subcomponent contains the reference (:normal) range.  The format of this field is where the range is taken to be inclusive (i.e.- the range includes the end points).  In this specification- the units are assumed to be identical to the reporting units given in OM2-3-units of measure)"`
	Sex            IS        `hl7:"2,table=0001,display=This subcomponent contains the sex of the patient.  Refer to user-defined table 0001 - Sex for suggested values"`
	AgeRange       *CM_RANGE `hl7:"3,display=This component contains the age range (in years or fractions thereof) specified as two values separated by a subcomponent delimiter (in order to allow a simple and consistent machine interpretation of this component).  Ages of less than one year should be specified as a fraction (e.g.- 1 month : 0.0830- 1 week : 0.01920- 1 day : 0.0027300).  However- for most purposes involving infants- the gestational age (measured in weeks) is preferred.  The lower end of the range is not indicated; the upper end is- assuring that series of ranges do not overlap"`
	AgeGestation   *CM_RANGE `hl7:"4,display=This component contains the gestational age and is relevant only when the reference range is influenced by the stage of pregnancy.  A range of values is required.  The gestational age is measured in weeks from conception.  For example- <1&10> implies that the normals apply to gestational ages from 1 week to 4 weeks inclusive (1&4).  The lower end of the range is not included; the upper end is- assuring  that series of age ranges do not overlap"`
	Species        TX        `hl7:"5,display=This component is assumed to be human unless otherwise stated.  The species should be represented as text (e.g.- rabbit- mouse- rat). "`
	RaceSubspecies ST        `hl7:"6,display=n the case of humans (the default)- the race is specified when race influences the reference range.  When normal ranges for animals are being described- this component can be used to describe subspecies or special breeds of animals"`
	Conditions     TX        `hl7:"7,display=This component contains the condition as simply free text.  This component allows for definition of normal ranges based on any arbitrary condition- e.g.- phase of menstrual cycle or dose of a particular drug.  It is provided as a way to communicate the normal ranges for special conditions.  It does not allow automatic checking of these text conditions"`
}

// Room Coverage
type CM_RMC struct {
	HL7            HL7Name `hl7:",name=CM_RMC,len=0,type=d"`
	RoomType       IS      `hl7:"1,table=0145,display=Room Type"`
	AmountType     IS      `hl7:"2,table=0146,display=Amount Type"`
	CoverageAmount NM      `hl7:"3,display=Coverage Amount"`
}

// Specialty
type CM_SPD struct {
	HL7                 HL7Name `hl7:",name=CM_SPD,len=0,type=d"`
	SpecialtyName       ST      `hl7:"1,display=Specialty Name"`
	GoverningBoard      ST      `hl7:"2,display=Governing Board"`
	EligibleOrCertified ID      `hl7:"3,table=0337,display=Eligible Or Certified"`
	DateOfCertification DT      `hl7:"4,format=YMD,display=Date Of Certification"`
}

// Specimen Source
type CM_SPS struct {
	HL7                          HL7Name `hl7:",name=CM_SPS,len=0,type=d"`
	SpecimenSourceNameOrCode     *CE     `hl7:"1,table=0070,display=Specimen Source Name Or Code"`
	Additives                    TX      `hl7:"2,display=Additives"`
	Freetext                     TX      `hl7:"3,display=Freetext"`
	BodySite                     *CE     `hl7:"4,display=Body Site"`
	SiteModifier                 *CE     `hl7:"5,display=Site Modifier"`
	CollectionModifierMethodCode *CE     `hl7:"6,display=Collection Modifier Method Code"`
}

// Value Code And Amount
type CM_UVC struct {
	HL7         HL7Name `hl7:",name=CM_UVC,len=0,type=d"`
	ValueCode   IS      `hl7:"1,table=0153,display=Value Code"`
	ValueAmount NM      `hl7:"2,display=Value Amount"`
}

// Value Qualifier
type CM_VR struct {
	HL7                HL7Name `hl7:",name=CM_VR,len=0,type=d"`
	FirstDataCodeValue ST      `hl7:"1,display=First Data Code Value"`
	LastDataCodeCalue  ST      `hl7:"2,display=Last Data Code Calue"`
}

// Composite ID Number And Name
//
// A field identifying a person both as a coded value and with a text name.  For specific fields, individual sites may elect to
// omit the ID or the name
//
// Example:
// |12372^RIGGINS^JOHN^""^""^""^MD^ADT1|
// |12372^^^^^^^ADT1|
// |^RIGGINS^JOHN^""^""^""^MD|
type CN struct {
	HL7                 HL7Name `hl7:",name=CN,len=0,type=d"`
	IDNumber            ST      `hl7:"1,display=Coded ID according to a user-defined table- defined by the 8th component.  If the first component is present- either the source table or the assigning authority must be valued"`
	FamilyName          ST      `hl7:"2,display=Family Name"`
	GivenName           ST      `hl7:"3,display=Given Name"`
	MiddleInitialOrName ST      `hl7:"4,display=Middle Initial Or Name"`
	Suffix              ST      `hl7:"5,display=Used to specify a name suffix (e.g.- Jr. or III). "`
	Prefix              ST      `hl7:"6,display=Used to specify a name prefix (e.g.- Dr.). "`
	Degree              ST      `hl7:"7,display=Used to specify an educational degree (e.g.- MD). "`
	SourceTable         ID      `hl7:"8,table=0297,display=Refer to user-defined table 0297 - CN ID source  for suggested values.  Used to delineate the first component"`
	AssigningAuthority  ST      `hl7:"9,display=Assigning Authority"`
}

// Composite Price
//
// Example:
// |100.00&USD^UP^0^9^min^P~50.00&USD^UP^10^59^min^P~10.00&USD^UP^60^999^P ~50.00&USD^AP~200.00&USD^PF~80.00&USD^DC|
type CP struct {
	HL7        HL7Name `hl7:",name=CP,len=0,type=d"`
	Price      *MO     `hl7:"1,display=The only required component; usually containing a decimal point. "`
	PriceType  ID      `hl7:"2,table=0205,display=A coded value- data type ID.  Refer to HL7 table 0205 - Price type for valid values"`
	FromValue  NM      `hl7:"3,display=Each is an NM data type; together they specify the “range.”  The range can be defined as either time or quantity.  For example- the range can indicate that the first 10 minutes of the procedure has one price.  Another repetition of the data type can use the range to specify that the following 10 to 60 minutes of the procedure is charged at another price per; a final repetition can specify that the final 60 to N minutes of the procedure at a third price"`
	ToValue    NM      `hl7:"4,display=See From value"`
	RangeUnits *CE     `hl7:"5,display=A coded value- data type CE- defined by the standard table of units for either time or quantity  (see for example- the tables in Section 7.1.4- “Coding schemes”).  This describes the units associated with the range- e.g.- seconds- minutes- hours- days- quantity (e.g.- count); it is required if <from value> and  <to value> are present"`
	RangeType  ID      `hl7:"6,table=0298,display=Refers to HL7 table 0298 - CP range type for valid values"`
}

// Composite Quantity With Units
//
// In future versions, CQ fields should be avoided because the same data can usually be sent as two separate fields, one with
// the value and one with the units as a CE data type
//
// Examples:
//
// |123.7^kg|  kilograms is an ISO unit
// |150^lb&&ANSI+| weight in pounds is a customary US unit defined within ANSI+
type CQ struct {
	HL7      HL7Name `hl7:",name=CQ,len=0,type=d"`
	Quantity NM      `hl7:"1,display=Quantity"`
	Units    ST      `hl7:"2,display=The units in which the quantity is expressed.  Field-by-field- default units may be defined within the specifications.  When the observation is measured in the default units- the units need not be transmitted.  If the measure is recorded in units different from the default- the measurement units must be transmitted as the second component.  If the units are ISO+ units- then units should be recorded as lowercase abbreviations as specified in Chapter 7.  If the units are ANSI or local- the units and the source table must be recorded as specified in Chapter 7.  But in these cases the component separator should be replaced by the subcomponent delimiter "`
}

// Extended Composite ID With Check Digit
//
// Example:
// |1234567^4^M11^ADT01^MR^University Hospital|
type CX struct {
	HL7                                        HL7Name `hl7:",name=CX,len=0,type=d"`
	ID                                         ST      `hl7:"1,display=Defined as in the CK data type (see Section 2.8.5- “CK - composite ID with check digit”) except that an ST data type is allowed instead of an NM data type"`
	CheckDigit                                 ST      `hl7:"2,display=Defined as in the CK data type (see Section 2.8.5- “CK - composite ID with check digit”) except that an ST data type is allowed instead of an NM data type.  The check digit in this data type is not an add-on produced by the message processor.  It is the check digit that is part of the identifying number used in the sending application.  If the sending application does not include a self-generated check digit in the identifying number- this component should be valued null. "`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"3,table=0061,display=The check digit scheme codes are defined in HL7 table 0061 - Check digit scheme"`
	AssigningAuthority                         *HD     `hl7:"4,display=The assigning authority is a unique name of the system that creates the data.  It is an HD data type.  It is equivalent to the application ID of the placer or filler order number (see Chapter 4).  Assigning authorities are unique across a given HL7 implementation. "`
	IdentifierTypeCode                         IS      `hl7:"5,table=0203,display=A code corresponding to the type of identifier.  In some cases- this code may be used as a qualifier to the “Assigning authority” component.  Refer to user-defined table 0203 - Identifier type for suggested values"`
	AssigningFacility                          *HD     `hl7:"6,display=The place or location identifier where the identifier was first assigned to the patient.  This component is not an inherent part of the identifier but rather part of the history of the identifier: as part of this data type- its existence is a convenience for certain intercommunicating systems"`
}

// Driver's License Number
//
// This field contains the driver’s license information.  For state or province refer to official postal codes for that country;
// for country refer to ISO 3166 for codes
type DLN struct {
	HL7                         HL7Name `hl7:",name=DLN,len=0,type=d"`
	DriverSLicenseNumber        ST      `hl7:"1,display=This field contains the driver’s license number"`
	IssuingStateProvinceCountry IS      `hl7:"2,display=Issuing authority for driver’s license.  For state or province refer to official postal codes for that country; for country refer to ISO 3166 for codes.  Refer to user-defined table 0333 - Driver’s license issuing authority"`
	ExpirationDate              DT      `hl7:"3,format=YMD,display=Expiration date (DT) for driver’s license"`
}

// Date Time Range
type DR struct {
	HL7                HL7Name `hl7:",name=DR,len=0,type=d"`
	RangeStartDateTime TS      `hl7:"1,format=YMDHMS,display=The first component contains the earliest date/time (time stamp) in the specified range"`
	RangeEndDateTime   TS      `hl7:"2,format=YMDHMS,display=The second component contains the latest date/time in the specified range."`
}

// Date
//
// In prior versions of HL7, this data type was  always specified to be in the format YYYYMMDD.  In the current and future versions,
// the precision of a date may be expressed by limiting the number of digits used with the format specification YYYY[MM[DD]].
// Thus, YYYY is used to specify a precision of “year,” YYYYMM specifies a precision of “month,” and YYYYMMDD specifies a precision
// of “day.”
//
// By site-specific agreement,  YYYYMMDD may be used where backward compatibility must be maintained.
//
// Examples:
//
// |19880704|
// |199503|
type DT = time.Time

// Entity Identifier
//
// The entity identifier defines a given entity within a specified series of identifiers.
//
// The specified series, the assigning authority, is defined by components 2 through 4.  The assigning authority is of the
// hierarchic designator data type, but it is defined as three separate components in the EI data type, rather than as a single
// component as would normally be the case.  This is in order to maintain backward compatibility with the EI’s use as a component
// in several existing data fields. Otherwise, the components 2 through 4 are as defined in Section 2.8.18, “HD - hierarchic
// designator.”  Hierarchic designators are unique across a given HL7 implementation
type EI struct {
	HL7              HL7Name `hl7:",name=EI,len=0,type=d"`
	EntityIdentifier ST      `hl7:"1,display=The first component- entity identifier- is usually defined to be unique within the series of identifiers created by the assigning authority- defined by a hierarchic designator- represented by components 2 through 4.  (See Section 2.8.18- “HD - hierarchic designator”.) "`
	NamespaceID      IS      `hl7:"2,table=0300,display=Refer to user-defined table 0300 - Namespace ID for suggested values"`
	UniversalID      ST      `hl7:"3,display=The HD’s second component- universal ID (UID)- is a string formatted according to the scheme defined by the third component- universal ID type (UID type).  The UID is intended to be unique over time within the UID type.  It is rigorously defined.  Each UID must belong to one of the specifically enumerated schemes for constructing UID’s (defined by the UID type).  The UID (second component) must follow the syntactic rules of the particular universal identifier scheme (defined by the third component). "`
	UniversalIDType  ID      `hl7:"4,table=0301,display=Refer to HL7 table 0301 - Universal ID type for valid values."`
}

// Financial Class
type FC struct {
	HL7            HL7Name `hl7:",name=FC,len=0,type=d"`
	FinancialClass IS      `hl7:"1,table=0064,display=This component contains the financial class assigned to a person. Refer to user-defined table 0064 - Financial class for suggested values"`
	EffectiveDate  TS      `hl7:"2,format=YMDHMS,display=This component contains the effective date/time of the person’s assignment to the financial class specified in the first component"`
}

// Formatted Text Data
//
// This data type is derived from the string data type by allowing the addition of embedded formatting instructions.  These
// instructions are limited to those that are intrinsic and independent of the circumstances under which the field is being
// used.  The actual instructions and their representation are described later in this chapter.  The FT field is of arbitrary
// length (up to 64k) and may contain formatting commands enclosed in escape characters.  Example:
// |\.sp\(skip one vertical line)|
//
// For additional examples of formatting commands see Section 2.9, “Use of escape sequences in text fields.”
type FT = string

// Hierarchic Designator
//
// The HD is designed to be a more powerful application identifier.  It is also designed to be used either as a local version of
// a site-defined application identifier or a publicly-assigned UID.  Syntactically, the HD is a group of two application
// identifiers: one defined by the first component, and one defined by the second and third components.
//
// The HD allows any site to act as an assigning authority (on a local or user-defined basis), even if it technically does not
// have the right to issue new IDs within an identification scheme.  HDs which have defined third components (defined UID types)
// must be unique within the series of ID’s defined by that component.
type HD struct {
	HL7             HL7Name `hl7:",name=HD,len=0,type=d"`
	NamespaceID     IS      `hl7:"1,table=0300,display=Refer to user-defined table 0300 - Namespace ID for suggested values"`
	UniversalID     ST      `hl7:"2,display=The HD’s second component- Universal ID (UID)- is a string formatted according to the scheme defined by the third component- Universal ID type (UID type).  The UID is intended to be unique over time within the UID type.  It is rigorously defined.  Each UID must belong  to one of the specifically enumerated schemes for constructing UID’s (defined by the UID type).  The UID (second component) must follow the syntactic rules of the particular universal identifier scheme (defined by the third component). "`
	UniversalIDType ID      `hl7:"3,table=0301,display=The third component governs the interpretation of the second component of the HD.  If the third component is a known UID refer to HL7 table 0301 - Universal ID type for valid values- then the second component is a universal ID of that type"`
}

// Coded values for HL7 tables
//
// The value of such a field follows the formatting rules for an ST field except that it is drawn from a table of legal values.
// There shall be an HL7 table number associated with ID data types. Examples of ID fields include MSH-12-version ID and OBR-25-result
// status. This data type should be used only for HL7 tables (see Section 2.6.7, ID number). The reverse is not true, since in
// some circumstances it is more appropriate to use the CE data type for HL7 tables.
type ID = string

// Coded value for user-defined tables
//
// The value of such a field follows the formatting rules for a ST field except that it is drawn from a site-defined (or user-defined)
// table of legal values. There shall be an HL7 table number associated with IS data types. An example of an IS field is the Event
// reason code defined in Section 3.3.1.4, Event reason code. This data type should be used only for user-defined tables (see
// Section 2.6.7, ID number). The reverse is not true, since in some circumstances, it is more appropriate to use the CE data
// type for user-defined tables.
type IS = string

// Job Code Class
type JCC struct {
	HL7      HL7Name `hl7:",name=JCC,len=0,type=d"`
	JobCode  IS      `hl7:"1,table=0327,display=This component contains the person’s  job code.  Refer to user-defined table 0327 - job code"`
	JobClass IS      `hl7:"2,table=0328,display=This component contains the person’s employee classification."`
}

// Location With Address Information (variant 1)
type LA1 struct {
	HL7                HL7Name `hl7:",name=LA1,len=0,type=d"`
	PointOfCare        IS      `hl7:"1,table=0302,display=Point Of Care"`
	Room               IS      `hl7:"2,table=0303,display=Room"`
	Bed                IS      `hl7:"3,table=0304,display=Bed"`
	Facility           *HD     `hl7:"4,display=Facility"`
	LocationStatus     IS      `hl7:"5,table=0306,display=Location Status"`
	PersonLocationType IS      `hl7:"6,table=0305,display=Person Location Type"`
	Building           IS      `hl7:"7,table=0307,display=Building"`
	Floor              IS      `hl7:"8,table=0308,display=Floor"`
	Address            *AD     `hl7:"9,display=Address"`
}

// Location With Address Information (variant 2)
type LA2 struct {
	HL7                        HL7Name `hl7:",name=LA2,len=0,type=d"`
	PointOfCare                IS      `hl7:"1,table=0302,display=Point Of Care"`
	Room                       IS      `hl7:"2,table=0303,display=Room"`
	Bed                        IS      `hl7:"3,table=0304,display=Bed"`
	Facility                   *HD     `hl7:"4,display=Facility"`
	LocationStatus             IS      `hl7:"5,table=0306,display=Location Status"`
	PersonLocationType         IS      `hl7:"6,table=0305,display=Person Location Type"`
	Building                   IS      `hl7:"7,table=0307,display=Building"`
	Floor                      IS      `hl7:"8,table=0308,display=Floor"`
	StreetAddress              ST      `hl7:"9,display=Street Address"`
	OtherDesignation           ST      `hl7:"10,display=Other Designation"`
	City                       ST      `hl7:"11,display=City"`
	StateOrProvince            ST      `hl7:"12,display=State Or Province"`
	ZipOrPostalCode            ST      `hl7:"13,display=Zip Or Postal Code"`
	Country                    ID      `hl7:"14,table=ISO3166,display=Country"`
	AddressType                ID      `hl7:"15,table=0190,display=Address Type"`
	OtherGeographicDesignation ST      `hl7:"16,display=Other Geographic Designation"`
}

// Money
type MO struct {
	HL7          HL7Name `hl7:",name=MO,len=0,type=d"`
	Quantity     NM      `hl7:"1,display=The first component is a quantity"`
	Denomination ID      `hl7:"2,table=ISO4217,display=The second component is the denomination in which the quantity is expressed.  The values for the denomination component are those specified in ISO-4217.  If the denomination is not specified- MSH-17country code is used to determine the default.   Example:  |99.50^USD|  where USD is the ISO 4217 code for the U.S. American dollar. "`
}

// Numeric
//
// A number represented as a series of ASCII numeric characters consisting of an optional leading sign ( + or -), the digits
// and an optional decimal point. In the absence of a sign, the number is assumed to be positive. If there is no decimal point
// the number is assumed to be an integer. Examples:
type NM = string

// Person Location
//
// This data type is used to specify a patient location within a healthcare institution. Which components are valued depends
// on the needs of the site.  It is most commonly used for specifying patient locations, but may refer to other types of persons
// within a healthcare setting.
type PL struct {
	HL7                HL7Name `hl7:",name=PL,len=0,type=d"`
	PointOfCare        IS      `hl7:"1,table=0302,display=Conditional on person location type (e.g.- nursing unit or department or clinic).  After floor- most general patient location designation.  Refer to user-defined table 0302 - Point of care for suggested values."`
	Room               IS      `hl7:"2,table=0303,display=Patient room.  After nursing unit- most general person location designation.  Refer to user-defined table 0303 - Room for suggested values"`
	Bed                IS      `hl7:"3,table=0304,display=Patient bed.  After room- most general person location designation.  Refer to user-defined table 0304 - Bed for suggested values"`
	Facility           *HD     `hl7:"4,display=Most general person location designation. (See Section 2.8.18- “HD - hierarchic designator”). "`
	LocationStatus     IS      `hl7:"5,table=0306,display=Location (e.g.- Bed) status.  Refer to user-defined table 0306 - Location status for suggested values"`
	PersonLocationType IS      `hl7:"6,table=0305,display=Usually includes values such as nursing unit- department- clinic- SNF- physician’s office.  Refer to userdefined table 0305 - Person location type for suggested values"`
	Building           IS      `hl7:"7,table=0307,display=After facility- most general person location designation.  Refer to user-defined table 0307 - Building for suggested values"`
	Floor              IS      `hl7:"8,table=0308,display=After building- most general person location designation.  Refer to user-defined table 0308 - Floor for suggested values"`
	LocationType       ST      `hl7:"9,display=A free text description of the location"`
}

// Performing Person Time Stamp
//
// This data type is the equivalent of an XCN data type joined with a TS data type.  However,  since HL7 does not support subcomponents
// in Version 2.3, the XCD data type has been flattened.
type PPN struct {
	HL7                                        HL7Name `hl7:",name=PPN,len=0,type=d"`
	IDNumber                                   ST      `hl7:"1,display=Coded ID according to a user-defined table- defined by the 8th component.  If the first component is present- either the source table or the assigning authority must be valued."`
	FamilyName                                 ST      `hl7:"2,display=Family Name"`
	GivenName                                  ST      `hl7:"3,display=Given Name"`
	MiddleInitialOrName                        ST      `hl7:"4,display=Middle Initial Or Name"`
	Suffix                                     ST      `hl7:"5,display=Suffix"`
	Prefix                                     ST      `hl7:"6,display=Prefix"`
	Degree                                     ST      `hl7:"7,display=Degree"`
	SourceTable                                ID      `hl7:"8,table=0297,display=Source Table"`
	AssigningAuthority                         *HD     `hl7:"9,display=In this version- an optional 9th component- the assigning authority (HD)- has been added.  It is an HD data type (see Section 2.8.18- “HD - hierarchic designator”)"`
	NameTypeCode                               ID      `hl7:"10,table=0200,display=A code that represents the type of name.  Refer to HL7 table 0200 - Name type for valid values (see Section 2.8.48- “XPN - extended person name”)."`
	IdentifierCheckDigit                       ST      `hl7:"11,display=The check digit in this data type is not an add-on produced by the message processor.  It is the check digit that is part of the identifying number used in the sending application.  If the sending application does not include a self-generated check digit in the identifying number- this component should be valued null"`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"12,table=0061,display=Refer to HL7 table 0061 - Check digit scheme for valid values"`
	IdentifierTypeCode                         IS      `hl7:"13,table=0203,display=A code corresponding to the type of identifier.  In some cases- this code may be used as a qualifier to the “Assigning authority” component.  Refer to user-defined table 0203 - Identifier type for suggested values"`
	AssigningFacility                          *HD     `hl7:"14,display=The place or location identifier where the identifier was first assigned to the patient.  This component is not an inherent part of the identifier but rather part of the history of the identifier:  as part of this data type- its existence is a convenience for certain intercommunicating systems. "`
	DateTimeActionPerformed                    TS      `hl7:"15,format=YMDHMS,display=This component describes when the activity was performed  Note: If this field is not null- both the performing person and the time stamp must be valued."`
}

// Processing Type
//
// This data type indicates whether to process a message as defined in HL7 Application (level 7) Processing rules
type PT struct {
	HL7            HL7Name `hl7:",name=PT,len=0,type=d"`
	ProcessingID   ST      `hl7:"1,table=0103,display=A value that defines whether the message is part of a production- training- or debugging system.  Refer to HL7 table 0103 - Processing ID for valid values"`
	ProcessingMode ST      `hl7:"2,table=0207,display=A value that defines whether the message is part of an archival process or an initial load.  Refer to HL7 table 0207 - Processing mode for valid values"`
}

// Query Input Parameter List
//
// Definition:  This field contains the list of parameter names and values to be passed to the stored procedure
type QIP struct {
	HL7                HL7Name `hl7:",name=QIP,len=0,type=d"`
	FieldName          ST      `hl7:"1,display=This component contains the field name.  Field naming conventions: Fields are designated by the “@” symbol concatenated with the HL7 item number for the field.  If the field is divided into components- the designation may be suffixed with “.nn-” to identify a particular component (a suffix of “.3” indicates the third component of the field); otherwise- the whole field is assumed.  If the field is further divided into subcomponents- the designation is suffixed with “.nn.mm-” which identifies the component and subcomponent requested by relative position.  Site-specific fields may be used- provided that they begin with the letter “Z.” In this case- site-specific item numbers must be defined that do not conflict with existing HL7 item numbers.  Values for this field are defined in the function-specific chapters of this specification. "`
	Value1Value2Value3 ST      `hl7:"2,display=This component contains the field value or values in the form “value1& value2 & value3 …”  A single valued parameter contains only a single subcomponent in the second component:  thus no subcomponent delimiters are needed (e.g.- <field name> ^ <value>).  A simple list of values (i.e.- a one-dimensional array) may be passed instead of a single value by separating each value with the subcomponent delimiter: -”<field name> ^ <value1 & value2 &…>” "`
}

// Query Selection Criteria
//
// This field indicates the conditions that qualify the rows to be returned in the query response.  (This field conveys the
// same information as the “WHERE” clause in the corresponding SQL expression of the query, but is formatted differently.)
//
type QSC struct {
	HL7                   HL7Name `hl7:",name=QSC,len=0,type=d"`
	NameOfField           ST      `hl7:"1,display=The name of the field that is participating as a qualifier (usually the “key”).  Refer to Section 2.8.30- “QIP - query input parameter list-” for field naming conventions"`
	RelationalOperator    ID      `hl7:"2,table=0209,display=Relational Operator"`
	Value                 ST      `hl7:"3,display=The value to which the field will be compared"`
	RelationalConjunction ID      `hl7:"4,table=0210,display=Refer to HL7 table 0102 - Relation conjunction for valid values.  The relational conjunction- defined as follows: If more than one comparison is to be made to select qualifying rows- a conjunction relates this repetition of the field to the next.  - When applied to strings- the relational operators LT- GT- LE- and GE imply an alphabetic comparison.  - A “generic” comparison selects a record for inclusion in the response when the beginning of the designated field matches the select string.   - Where a repeating field is specified as an operand- a match on any instance of that field qualifies the row for inclusion in the response message.  - AND takes precedence over OR.  More sophisticated precedence rules require that the query be expressed as an embedded query language message or a stored procedure query message (see Section 2.19- “ENHANCED MODE QUERY MESSAGES-” and also Sections 2.24.16- “EQL - embedded query language segment-” and 2.24.20- “SPR - stored procedure request definition segment.”"`
}

// Row Column Definition
//
// Each repetition of this field consists of three components
type RCD struct {
	HL7                HL7Name `hl7:",name=RCD,len=0,type=d"`
	HL7ItemNumber      ST      `hl7:"1,display=The HL7 item number- which identifies the field occupying the column.  (Refer to Section 2.8.30- “QIP - query input parameter list-” for item numbering conventions.) "`
	HL7DateType        ST      `hl7:"2,display=The two or three character HL7 data type- as defined in Section 2.8- “Data types'"`
	MaximumColumnWidth NM      `hl7:"3,display=The maximum width of the column- as dictated by the responding system.  (This may vary from the HL7defined maximum field length.) "`
}

// Repeat Interval
//
// This field contains the interval between repeating appointments.  The default setting indicates that the appointment
// should occur once, when the component is not valued.  The definition of this field is equivalent to the definition of the
// Interval component of the Quantity/Timing field given in Chapter 4, Section 4.4.2 “Interval component (CM).”
type RI struct {
	HL7                  HL7Name `hl7:",name=RI,len=0,type=d"`
	RepeatPattern        IS      `hl7:"1,table=0335,display=The first component is defined by user-defined table 0335 - Repeat pattern. See Section  4.4.2.1 “Repeat pattern-”  for further details"`
	ExplicitTimeInterval ST      `hl7:"2,display=The second component explicitly lists the actual times referenced by the code in the first subcomponent- in the following format: HHMM-HHMM-HHMM-.…  This second subcomponent will be used to clarify the first subcomponent in cases where the actual administration times vary within an institution. See Section 4.4.2.2- “Explicit time interval subcomponent-” for further details."`
}

// Scheduling Class Value Pair
//
// For use only with the scheduling chapter.
//
// This field is used to communicate parameters and preferences to the filler application regarding the selection of an appropriate
// time slot, resource, location, or filler override criterion  for an appointment
type SCV struct {
	HL7            HL7Name `hl7:",name=SCV,len=0,type=d"`
	ParameterClass IS      `hl7:"1,display=The first component of this field is a code identifying the parameter or preference being passed to the filler application"`
	ParameterValue ST      `hl7:"2,display=The second component is the actual data value for that parameter.  For example- if a filler application allows preference parameters to be passed to specify a preferred start time- a preferred end time- and preferred days of the week for the appointment- it may define the following parameter class codes and valid data sets"`
}

// Sequence ID
//
// A non-negative integer in the form of an NM field.  The uses of this data type are defined in the chapters defining the segments
// and messages in which it appears
type SI = string

// String Data
//
// To include any HL7 delimiter character (except the segment terminator) within a string data field, use the appropriate
// HL7 escape sequence (see Section 2.9.1, Formatting codes).
type ST = string

// Time
//
// Format: HH[MM[SS[.S[S[S[S]]]]]][+/-ZZZZ]
//
// In prior versions of HL7, this data type was always specified to be in the format HHMM[SS[.SSSS]][+/ZZZZ] using a 24 hour
// clock notation.  In the current and future versions, the precision of a time may be expressed by limiting the number of digits
// used with the format specification as shown above.  By sitespecific agreement, HHMM[SS[.SSSS]][+/-ZZZZ] may be used
// where backward compatibility must be maintained.
//
// Thus, HH is used to specify a precision of “hour,” HHMM is used to specify a precision of “minute,” HHMMSS is used to specify
// a precision of seconds, and HHMMSS.SSSS is used to specify a precision of  ten-thousandths of a second.
//
// In each of these cases, the time zone is an optional component. The fractional seconds could be sent by a transmitter who
// requires greater precision than whole seconds.  Fractional representations of minutes, hours or other higher orders
// units of time are not permitted.
// The time zone of the sender may be sent optionally as an offset from the coordinated universal time (previously known as
// Greenwich Mean Time).  Where the time zone is not present in a particular TM field but is included as part of the date/time
// field in the MSH segment, the MSH value will be used as the default time zone.  Otherwise, the time is understood to refer to
// the local time of the sender.  Midnight is represented as 0000.
//
// Examples:
//
// 1 second before midnight in a time zone eleven hours ahead of Universal Coordinated Time (i.e., east of Greenwich).
// |235959+1100|
//
// Eight AM, local time of the sender.
// |0800|
//
// 44.2312 seconds after Nine thirty-five AM, local time of sender.
// |093544.2312|
//
// 1pm (with a precision of hours), local time of sender.
// |13|
type TM = time.Time

// Telephone Number
//
// For use in the United States and conforming countries, the telephone number is always in the form:
//
// Format:  [NN] [(999)]999-9999[X99999][B99999][C any text]
//
// The optional first two digits are the country code.  The optional X portion gives an extension.  The optional B portion gives
// a beeper code.  The optional C portion may be used for comments like, After 6:00.  While no explicit limit is placed on the text
// field, receiving systems may be expected to truncate values that are more than 10 characters long.  To accommodate the variability
// of institutional phone systems, the length of the extension and beeper numbers may be extended by local agreement.
//
// Examples:
// |(415)925-0121X305|
// |234-4532CWEEKENDS|
type TN = string

// Timing Quantity
//
// Quantity/timing (ORC-7, OBR-27) provides a means of specifying when the service described by the order segment is to be
// performed and how frequently.  It is a complex multicomponent field that can have repeats; i.e., more than one quantity/timing
// specification, separated by repeat delimiters, may appear.  It is a distinct data type (see Section 2.8.41, “TQ - timing
// quantity”).  The components of a single quantity/timing specification are described in the Sections: 4.4.1, “Quantity
// component  (CQ),” through 4.4.10, “Order sequencing component (CM).”
type TQ struct {
	HL7             HL7Name `hl7:",name=TQ,len=0,type=d"`
	Quantity        *CQ     `hl7:"1,display=This field is the quantity of the service that should be provided at each service interval.  For example.- if two blood cultures are to be obtained every 4 hours- the quantity would be 2.  If three units of blood are to be typed and cross-matched- the quantity would be 3.  The default value is 1.  When units are required- they can be added- specified by a subcomponent delimiter. "`
	Interval        *RI     `hl7:"2,display=This field determines the interval between repeated services.  The default is one time only- the first subcomponent is the repeat pattern- and the second subcomponent is the explicit time at which pattern is to be executed"`
	Duration        ST      `hl7:"3,display=This field indicates how long the service should continue after it is started.  The default is INDEF (do indefinitely)  S<integer> : <integer> seconds  M<integer> : <integer> minutes  H<integer> : <integer> hours  D<integer> : <integer> days  W<integer> : <integer> weeks  L<integer> : <integer> months  X<integer> : <integer> times at interval specified in the order.  A request for 2 blood cultures Q2H X3 would imply obtaining 2 blood cultures 3 different times at 2-hour intervals for a total of 6 blood cultures.  T<integer> : at the interval and amount stated until a total of <integer> “DOSAGE” is accumulated.  Units would be assumed to be the same as in the QUANTITY field. INDEF : do indefinitely - also the default "`
	StartDateTime   TS      `hl7:"4,format=YMDHMS,display=This field may be specified by the orderer- in which case it indicates the earliest date/time at which the services should be started.  In many cases- however- the start date/time will be implied or will be defined by other fields in the order record (e.g.- urgency - STAT).  In such a case- this field will be empty.    The filling service will often record a value in this field after receipt of the order- however- and compute an end time on the basis of the start date/time for the filling service’s internal use. "`
	EndDateTime     TS      `hl7:"5,format=YMDHMS,display=When filled in by the requester of the service- this field should be the latest date/time that the service should be performed.  If it has not been performed by the specified time- it should not be performed at all.  The requester may not always fill in this value- yet the filling service may fill it in on the basis of the instruction it receives and the actual start time.    Regardless of the value of the end date/time- the service should be stopped at the earliest of the date/times specified by either the duration or the end date/time."`
	Priority        ST      `hl7:"6,display=This field describes the urgency of the request.  The following values are suggested (the default for Priority is R):  S : Stat With highest priority  A : ASAP Fill after S orders  R : Routine Default  P : Preop   C : Callback   T : Timing critical A request implying that it is critical to come as close as possible to the requested time- e.g.- for a trough antimicrobial level.  PRN : As needed  If using the value “T” (timing critical)- the degree of criticality can be specified thus:   Format:  TS<integer> : timing critical within <integer> seconds  TM<integer> : timing critical within <integer> minutes  TH<integer> : timing critical within <integer> hours  TD<integer> : timing critical within <integer> days  TW<integer> : timing critical within <integer> weeks  TL<integer> : timing critical within <integer> months   For the sequential orders specification- these values specify the time criticality with which the predecessor order must be followed by the given order.  The priority component may repeat; separate repeating values with the repeat delimiter separated by a space"`
	Condition       ST      `hl7:"7,display=This is a free text field that describes the conditions under which the drug is to be given.  For example- PRN pain- or to keep blood pressure below 110.  The presence of text in this field should be taken to mean that human review is needed to determine the how and/or when this drug should be given"`
	Text            TX      `hl7:"8,display=This field is a full text version of the instruction (optional)"`
	Conjunction     ST      `hl7:"9,display=This non-null component indicates that a second timing specification is to follow using the repeat delimiter.  This field can take three values:    S :  Synchronous   Do the next specification after this one (unless otherwise constrained by the following components: ORC4^4-start date/time and ORC-4^5-end date/time).   An “S” specification implies that the second timing sequence follows the first- e.g.- when an order is written to measure blood pressure Q15 minutes for the 1st hour- then every 2 hours for the next day.    A :  Asynchronous   Do the next specification in parallel with this one (unless otherwise constrained by the following components: ORC-4^4-start date/time and ORC-4^5-end date/time).  The conjunction of “A” specifies two parallel instructions- as are sometimes used in medication- e.g.- prednisone given at 1 tab on Monday- Wednesday- Friday- and at 1/2 tab on Tuesday- Thursday- Saturday- Sunday.    C :  This is an actuation time  It will be followed by a completion time for the service.  This code allows one to distinguish between the time and priority at which a service should be actuated (e.g.- blood should be drawn) and the time and priority at which a service should be completed (e.g.- results should be reported)"`
	OrderSequencing *CM_OSD `hl7:"10,display=There are many situations- such as the creation of an order for a group of intravenous (IV) solutions- where the sequence of the individual intravenous solutions (each a service in itself) needs to be specified- e.g.- hyperalimentation with multi-vitamins in every third bottle.   There are other situations where part of the order’s instructions contains a results condition of some type- such as “PRN pain.”  There is currently a free text “condition” component of ORC-4-quantity/timing which allows any condition to be specified.  However- to support a fully encoded version of order sequencing- or results condition- we have defined in the following paragraphs a 10th component of ORC-4-quantity/timing.    The sequencing conditions supported by this 10th component are based on the completion of a  predecessor service"`
}

// Time Stamp
//
// Contains the exact time of an event, including the date and time. The date portion of a time stamp follows the rules of a date
// field and the time portion follows the rules of a time field. The time zone (+/-ZZZZ) is represented as +/-HHMM offset from
// UCT (formerly Greenwich Mean Time (GMT)), where +0000 or -0000 both represent UCT (without offset). The specific data
// representations used in the HL7 encoding rules are compatible with ISO 8824-1987(E).
type TS = time.Time

// Text Data
//
// String data meant for user display (on a terminal or printer).  Such data would not necessarily be left justified since leading
// spaces may contribute greatly to the clarity of the presentation to the user.  Because this type of data is intended for display,
// it may contain certain escape character sequences designed to control the display.  Escape sequence formatting is defined
// later in this chapter in Section 2.9, “Use of escape sequences in text fields.”  Leading spaces should be included.  Trailing
// spaces should be removed.
//
// Example:
// |  leading spaces are allowed.|
//
// Since TX data is intended for display purposes, the repeat delimiter, when used with a TX data field, implies a series of
// repeating lines to be displayed on a printer or terminal.  Therefore, the repeat delimiters are regarded as paragraph terminators
// or hard carriage returns (e.g., they would display as though a CR/LF were inserted in the text (DOS type system) or as though
// a LF were inserted into the text (UNIX style system)).
//
// A receiving system would word-wrap the text between repeat delimiters in order to fit it into an arbitrarily sized display
// window but start any line beginning with a repeat delimiter on a new line.
//
// Usage note: the maximum length of a TX data field is 64K
type TX = string

// Variable Datatype
type VARIES = CE

// Visiting Hours
//
// This data type contains the hours when a patient location is open for visiting.  Refer to HL7 table 0267 - Days of the week for
// valid values for the first two components
type VH struct {
	HL7            HL7Name `hl7:",name=VH,len=0,type=d"`
	StartDayRange  ID      `hl7:"1,table=0267,display=Starting day of visiting hours range.  See HL7 table 0267 - Days of the week for values"`
	EndDayRange    ID      `hl7:"2,table=0267,display=Ending day of visiting hours range.  Starting day of visiting hours range.  See HL7 table 0267 - Days of the week for values "`
	StartHourRange TM      `hl7:"3,format=HM,display=Starting hour on starting day of visiting hours range (see first component- 2.8.44.1- “Start day range”). "`
	EndHourRange   TM      `hl7:"4,format=HM,display=Ending hour on ending day of visiting hours range (see second component- 2.8.44.2- “End day range”). "`
}

// Extended Address
//
// Example:
// |1234 Easy St.^Ste. 123^San Francisco^CA^95123^USA^B^^SF^|
type XAD struct {
	HL7                        HL7Name `hl7:",name=XAD,len=0,type=d"`
	StreetAddress              ST      `hl7:"1,table=Street,display=The street or mailing address of a person or institution"`
	OtherDesignation           ST      `hl7:"2,display=Second line of address.  In general- it qualifies address.  Examples:  Suite 555 or Fourth Floor"`
	City                       ST      `hl7:"3,table=City,display=City"`
	StateOrProvince            ST      `hl7:"4,table=State,display=tate or province should be represented by the official postal service codes for that country"`
	ZipOrPostalCode            ST      `hl7:"5,table=ZipCode,display=Zip or postal codes should be represented by the official codes for that country.  In the US- the zip code takes the form 99999[-9999]- while the Canadian postal code takes the form A9A-9A9"`
	Country                    ID      `hl7:"6,table=ISO3166,display=Defines the country of the address.  ISO 3166 provides a list of country codes that may be used"`
	AddressType                ID      `hl7:"7,table=0190,display=Address type is optional and defined by HL7 table 0190 - Address type"`
	OtherGeographicDesignation ST      `hl7:"8,display=Other geographic designation includes country- bioregion- SMSA- etc"`
	CountyParishCode           IS      `hl7:"9,table=0289,display=A code that represents the county in which the specified address resides. Refer to user-defined table 0289 - County/parish.  When this component is used to represent the county (or parish)- component 8 “other geographic designation” should not duplicate it (i.e.- the use of “other geographic designation” to represent the county is allowed only for the purpose of backward compatibility- and should be discouraged in this and future versions of HL7).  Allowable values:  codes defined by government"`
	CensusTract                IS      `hl7:"10,table=0288,display=A code that represents the census track in which the specified address resides. Refer to user-defined table 0288 - Census tract.  Allowable Values:  codes defined by government"`
}

// Extended Composite ID Number And Name
//
// Example:
// |1234567^Smith^John^J^III^DR^PHD^ADT01^^L^4^M11^MR|
type XCN struct {
	HL7                                        HL7Name `hl7:",name=XCN,len=0,type=d"`
	IDNumber                                   ST      `hl7:"1,display=Coded ID according to a user-defined table- defined by the 8th component.  If the first component is present- either the source table or the assigning authority must be valued"`
	FamilyName                                 ST      `hl7:"2,display=Family Name"`
	GivenName                                  ST      `hl7:"3,table=FirstName,display=Given Name"`
	MiddleInitialOrName                        ST      `hl7:"4,display=Middle Initial Or Name"`
	Suffix                                     ST      `hl7:"5,display=Suffix"`
	Prefix                                     ST      `hl7:"6,display=Prefix"`
	Degree                                     ST      `hl7:"7,display=Degree"`
	SourceTable                                IS      `hl7:"8,table=0297,display=Refer to user-defined table 0207 - CN ID source for suggested values.  Used to delineate the first component. "`
	AssigningAuthority                         *HD     `hl7:"9,display= In this version an optional 9th component- the assigning authority (HD)- has been added.  It is an HD data type (see Section 2.8.18- “HD - hierarchic designator”). "`
	NameType                                   ID      `hl7:"10,table=0200,display=A code that represents the type of name.  Refer to HL7 table 0200 - Name type for valid values (see Section 2.8.48- “XPN - extended person name”). "`
	IdentifierCheckDigit                       ST      `hl7:"11,display=The check digit in this data type is not an add-on produced by the message processor.  It is the check digit that is part of the identifying number used in the sending application.  If the sending application does not include a self-generated check digit in the identifying number- this component should be valued null"`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"12,table=0061,display=Refer to HL7 table 0060 - Check digit scheme for valid values"`
	IdentifierTypeCode                         IS      `hl7:"13,table=0203,display=A code corresponding to the type of identifier.  In some cases- this code may be used as a qualifier to the “Assigning authority” component.  Refer to user-defined table 0203 - Identifier type for suggested values"`
	AssigningFacilityID                        *HD     `hl7:"14,display=The place or location identifier where the identifier was first assigned to the patient.  This component is not an inherent part of the identifier but rather part of the history of the identifier:  as part of this data type- its existence is a convenience for certain intercommunicating systems."`
}

// Extended Composite Name And ID For Organizations
//
// Example:
// |HL7 Health Center^L^6^M11^HCFA|
type XON struct {
	HL7                                        HL7Name `hl7:",name=XON,len=0,type=d"`
	OrganizationName                           ST      `hl7:"1,display=The name of the specified organization"`
	OrganizationNameTypeCode                   IS      `hl7:"2,table=0204,display=A code that represents the type of name i.e.- legal name- display name.  Refer to user-defined table 0204 - Organizational name type for suggested values. "`
	IDNumber                                   NM      `hl7:"3,display=ID Number"`
	CheckDigit                                 ST      `hl7:"4,display=The check digit in this data type is not an add-on produced by the message processor.  It is the check digit that is part of the identifying number used in the sending application.  If the sending application does not include a self-generated check digit in the identifying number- this component should be valued null"`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"5,table=0061,display=The check digit scheme codes are defined in HL7 table 0061 - Check digit scheme"`
	AssigningAuthority                         *HD     `hl7:"6,display=The assigning authority is a unique name of the system that creates the data.  It is an HD data type.  It is equivalent to the application ID of the placer or filler order number (see Chapter 4).  Assigning authorities are unique across a given HL7 implementation"`
	IdentifierTypeCode                         IS      `hl7:"7,table=0203,display=A code corresponding to the type of identifier.  In some cases- this code may be used as a qualifier to the “Assigning authority” component.  Refer to user-defined table 0203 - Identifier type for suggested values"`
	AssigningFacilityID                        *HD     `hl7:"8,display=The assigning facility is a unique identifier of the system that creates the data.  It is an HD data type.  It is equivalent to the application ID of the placer or filler order number (see Chapter 4).  Assigning authorities are unique across a given HL7 implementation"`
}

// Extended Person Name
//
// Example:
// |Smith^John^J^III^DR^PHD^L|
type XPN struct {
	HL7                    HL7Name `hl7:",name=XPN,len=0,type=d"`
	FamilyName             ST      `hl7:"1,table=LastName,display=Family Name"`
	GivenName              ST      `hl7:"2,table=FirstName,display=Given Name"`
	MiddleInitialOrName    ST      `hl7:"3,display=Middle Initial Or Name"`
	Suffix                 ST      `hl7:"4,display=Suffix"`
	Prefix                 ST      `hl7:"5,display=Prefix"`
	Degree                 ST      `hl7:"6,display=Degree"`
	NameTypeCode           ID      `hl7:"7,table=0200,display=A code that represents the type of name.  Refer to HL7 table 0200 - Name type for valid values"`
	NameRepresentationCode ID      `hl7:"8,table=4000,display=In general this component provides an indication of the representation provided by the data item.  It does not necessarily specify the character sets used. Thus- even though the representation might provide an indication of what to expect- the sender is still free to encode the contents using whatever character set is desired.  This component provides only hints for the receiver- so it can make choices regarding what it has been sent and what it is capable of displaying"`
}

// Extended Telecommunication Number
//
// Example:
// (415)555-3210^ORN^FX^
type XTN struct {
	HL7                            HL7Name `hl7:",name=XTN,len=0,type=d"`
	TelephoneNumber                TN      `hl7:"1,table=PhoneNumber,display=Defined as the TN data type ( see Section 2.8.40- “TN - telephone number”)- except that the length of the country access code has been increased to three"`
	TelecommunicationUseCode       ID      `hl7:"2,table=0201,display=A code that represents a specific use of a telecommunication number.  Refer to HL7 table 0201 - Telecommunication use code for valid values"`
	TelecommunicationEquipmentType ID      `hl7:"3,table=0202,display=A code that represents the type of telecommunication equipment.  Refer to HL7 table 0202 - Telecommunication equipment type for valid values"`
	EmailAddress                   ST      `hl7:"4,display=Note: Components five through nine reiterate the basic function of the first component in a delimited form that allows the expression of both local and international telephone numbers.  In Version 2.3- the recommended form for the telephone number is to use the delimited form rather than the unstructured form supported by the first component (which is left in for backward compatibility only). "`
	CountryCode                    NM      `hl7:"5,display=Country Code"`
	AreaCityCode                   NM      `hl7:"6,display=Area/city Code"`
	PhoneNumber                    NM      `hl7:"7,display=Phone Number"`
	Extension                      NM      `hl7:"8,display=Extension"`
	AnyText                        ST      `hl7:"9,display=Any Text"`
}
