// Code generated by "hl7fetch -pkgdir h220 -root ./genjson -version 2.2"; DO NOT EDIT.

package h220

import "time"

// Address
//
// All components are ST data type.  The street or mailing address of a person or institution.
type AD struct {
	HL7                        HL7Name `hl7:",name=AD,len=0,type=d"`
	StreetAddress              ST      `hl7:"1,display=Street Address"`
	OtherDesignation           ST      `hl7:"2,display=Other Designation"`
	City                       ST      `hl7:"3,display=City"`
	StateOrProvince            ST      `hl7:"4,display=State Or Province"`
	ZipOrPostalCode            ID      `hl7:"5,display=Zip Or Postal Code"`
	Country                    ID      `hl7:"6,table=ISO3166,display=Country"`
	Type                       ID      `hl7:"7,table=0190,display=Type"`
	OtherGeographicDesignation ST      `hl7:"8,display=Other Geographic Designation"`
}

// Coded Element
//
// This data type transmits codes and the text associated with the code.
//
// Example:
// |54.21^Laparoscopy^I9^42112^^AS4|
type CE struct {
	HL7                         HL7Name `hl7:",name=CE,len=0,type=d"`
	Identifier                  ID      `hl7:"1,display=Sequence of characters (the code) that uniquely identifies the item being referenced by the <text>.  Different coding schemes will have different elements here."`
	Text                        ST      `hl7:"2,display=Name or description of the item in question.  E.g.- myocardial infarction or x-ray impression.  Its data type is string (ST)."`
	NameOfCodingSystem          ST      `hl7:"3,display=Each coding system will be assigned a unique identifier.  This component will serve to identify the coding scheme being used in the identifier component. The combination of the identifier and name of coding system components will be a unique code for a data item.  For backward compatibility- if this component is absent- it will be taken to mean the CPT-4 with ASTM extensions- i.e.- AS4.  Other coding systems that might appear here are ICD-9- ICD-10- SNOMED- etc.  Each system will be given a unique identifying string.  The current ASTM 1238-88  diagnostic/procedure/observation/drug ID/health outcomes coding systems are identified in the tables below.  Others may be added as needed."`
	AlternateIdentifier         ST      `hl7:"4,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally defined system"`
	AlternateText               ST      `hl7:"5,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally defined system"`
	NameOfAlternateCodingSystem ST      `hl7:"6,display=These three components are defined analogously to the above for the alternate or local coding system.  If the Alternate Text component is absent- and the Alternate Identifier is present- the Alternate Text will be taken to be the same as the Text component.  If the Alternate Coding System component is absent- it will be taken to mean the locally defined system"`
}

// Composite Id With Check Digit
//
// This data type is used for certain fields that commonly contain check digits, e.g., PID-3-Patient ID (Internal ID).  If
// a site is not using check-digits for a particular CK field, the second and third components are not valued.
//
// Example:
// |128952^6^M11^ADT01|
type CK struct {
	HL7                                        HL7Name `hl7:",name=CK,len=0,type=d"`
	IDNumber                                   NM      `hl7:"1,display=ID Number"`
	CheckDigit                                 NM      `hl7:"2,display=Check Digit"`
	CodeIdentifyingTheCheckDigitSchemeEmployed ID      `hl7:"3,table=0061,display=The check digit scheme codes are defined in table 0061 - check digit scheme. "`
	AssigningFacilityID                        ST      `hl7:"4,display=The assigning facility ID is a unique name (up to six characters in length) of the system that stores the data.  It is an ST data type.  It is equivalent to the application ID of the placer or filler order number (see Chapter 4).  Assigning facility ID's are unique across a given HL7 implementation."`
}

// Authorization Information
type CM_AUI struct {
	HL7                 HL7Name `hl7:",name=CM_AUI,len=0,type=d"`
	AuthorizationNumber ST      `hl7:"1,display=Authorization Number"`
	Date                DT      `hl7:"2,format=YMD,display=Date"`
	Source              ST      `hl7:"3,display=Source"`
}

// Cm For Batch Totals
//
// as many types of totals as needed for the batch may be carried by this field as separate  components.  Each component is an NM
// data type
type CM_BATCH_TOTAL struct {
	HL7         HL7Name `hl7:",name=CM_BATCH_TOTAL,len=0,type=d"`
	BatchTotal  NM      `hl7:"1,display=Batch Total 1"`
	BatchTotal2 NM      `hl7:"2,display=Batch Total 2"`
	Value       NM      `hl7:"3,display=..."`
}

// Charge Time
type CM_CCD struct {
	HL7          HL7Name `hl7:",name=CM_CCD,len=0,type=d"`
	WhenToCharge ID      `hl7:"1,table=0100,display=When To Charge"`
	DateTime     TS      `hl7:"2,format=YMDHMS,display=Date/Time"`
}

// Daily Deductible
type CM_DDI struct {
	HL7          HL7Name `hl7:",name=CM_DDI,len=0,type=d"`
	DelayDays    ST      `hl7:"1,display=Delay Days"`
	Amount       NM      `hl7:"2,display=Amount"`
	NumberOfDays NM      `hl7:"3,display=Number Of Days"`
}

// Discharge Location
type CM_DLD struct {
	HL7         HL7Name `hl7:",name=CM_DLD,len=0,type=d"`
	Code        ID      `hl7:"1,table=0113,display=Code"`
	Description ST      `hl7:"2,display=Description"`
}

// Day Type And Number
type CM_DTN struct {
	HL7          HL7Name `hl7:",name=CM_DTN,len=0,type=d"`
	DayType      ID      `hl7:"1,table=0149,display=Day Type"`
	NumberOfDays NM      `hl7:"2,display=Number Of Days"`
}

// Parent Order
type CM_EIP struct {
	HL7                      HL7Name `hl7:",name=CM_EIP,len=0,type=d"`
	ParentsPlacerOrderNumber ST      `hl7:"1,display=The first component contains the placer order number of the parent order.  It is required when the order is a child"`
	ParentsFillerOrderNumber ST      `hl7:"2,display=The second component contains the filler order number of the parent order."`
}

// Error
type CM_ELD struct {
	HL7                  HL7Name `hl7:",name=CM_ELD,len=0,type=d"`
	SegmentID            ST      `hl7:"1,display=Segment-id"`
	Sequence             NM      `hl7:"2,display=Sequence"`
	FieldPosition        NM      `hl7:"3,display=Field-position"`
	CodeIdentifyingError *CE     `hl7:"4,table=0060,display=Code Identifying Error"`
}

// Number Of Processing Power Point
type CM_FILLER struct {
	HL7                 HL7Name `hl7:",name=CM_FILLER,len=0,type=d"`
	UniqueFillerID      ID      `hl7:"1,display=Its first component is a string of up to 15 characters that identifies an order detail segment (e.g.- OBR). It is assigned by the order filler (receiving) application. This string must uniquely identify the order (as specified in the order detail segment) from other orders in a particular filling application (e.g.- clinical laboratory).  This uniqueness must persist over time. "`
	FillerApplicationID ID      `hl7:"2,display=The second component contains the filler application ID.  The filler application ID is a string of up to six characters that uniquely defines the application from other applications on the network.  The second component of the filler order number always identifies the actual filler of an order. "`
}

// Cm Of Finance
type CM_FINANCE struct {
	HL7              HL7Name `hl7:",name=CM_FINANCE,len=0,type=d"`
	FinancialClassID ID      `hl7:"1,table=0064,display=Financial Class Id"`
	EffectiveDate    TS      `hl7:"2,format=YMDHMS,display=Effective Date"`
}

// Order Group Number
type CM_GROUP_ID struct {
	HL7                 HL7Name `hl7:",name=CM_GROUP_ID,len=0,type=d"`
	UniqueGroupID       ID      `hl7:"1,display=The first component is a string of up to 15 characters that uniquely identifies all order groups from the given placer application.  It is assigned by the placer application and may come from the same series as the placer order number of the ORC- but this is not required. "`
	PlacerApplicationID ID      `hl7:"2,display=The second component is a placer application ID identical to the second component of ORC-2-placer order number.  Order groups and how to use them are described in detail at the end of the ORC section under 'Use Notes' and in the Examples."`
}

// Cm For Location Information In Hospital
type CM_INTERNAL_LOCATION struct {
	HL7              HL7Name `hl7:",name=CM_INTERNAL_LOCATION,len=0,type=d"`
	NurseUnitStation ID      `hl7:"1,display=Nurse Unit (station)"`
	Room             ID      `hl7:"2,display=Room"`
	Bed              ID      `hl7:"3,display=Bed"`
	FacilityID       ID      `hl7:"4,display=Facility Id"`
	BedStatus        ID      `hl7:"5,display=Bed Status"`
}

// Job Title
type CM_JOB_CODE struct {
	HL7                    HL7Name `hl7:",name=CM_JOB_CODE,len=0,type=d"`
	JobCode                ID      `hl7:"1,display=Job Code"`
	EmployeeClassification ID      `hl7:"2,display=Employee Classification"`
}

// Location With Address Information
type CM_LA1 struct {
	HL7                       HL7Name               `hl7:",name=CM_LA1,len=0,type=d"`
	DispenseDeliverToLocation *CM_INTERNAL_LOCATION `hl7:"1,display=Dispense / Deliver To Location"`
	Location                  *AD                   `hl7:"2,display=The second component can be used to specify an address.  This could be used to fill mail orders to a patient or provider- or to account for home health care. "`
}

// Cm For Driving License
type CM_LICENSE_NO struct {
	HL7                         HL7Name `hl7:",name=CM_LICENSE_NO,len=0,type=d"`
	LicenseNumber               ST      `hl7:"1,display=License Number"`
	IssuingStateProvinceCountry ST      `hl7:"2,display=Issuing State-province-country"`
}

// Charge To Practise
type CM_MOC struct {
	HL7          HL7Name `hl7:",name=CM_MOC,len=0,type=d"`
	DollarAmount ST      `hl7:"1,display=Dollar Amount"`
	ChargeCode   ST      `hl7:"2,display=Charge Code"`
}

// Message Type
type CM_MSG struct {
	HL7          HL7Name `hl7:",name=CM_MSG,len=0,type=d"`
	MessageType  ID      `hl7:"1,table=0076,display=Message Type"`
	TriggerEvent ID      `hl7:"2,table=0003,display=Trigger Event"`
}

func (d CM_MSG) MessageStructureID() []string {
	if len(d.TriggerEvent) == 0 {
		return []string{d.MessageType}
	}
	return []string{d.MessageType + "_" + d.TriggerEvent, d.MessageType}
}

// Observing Practitioner
type CM_NDL struct {
	HL7                   HL7Name               `hl7:",name=CM_NDL,len=0,type=d"`
	InterpreterTechnician *CN_PERSON            `hl7:"1,display=Interpreter / Technician"`
	StartDateTime         TS                    `hl7:"2,format=YMDHMS,display=Start Date/Time"`
	EndDateTime           TS                    `hl7:"3,format=YMDHMS,display=End Date/Time"`
	Location              *CM_INTERNAL_LOCATION `hl7:"4,display=Location"`
}

// Occurence
type CM_OCD struct {
	HL7            HL7Name `hl7:",name=CM_OCD,len=0,type=d"`
	OccurrenceCode ID      `hl7:"1,display=Occurrence Code"`
	OccurrenceDate DT      `hl7:"2,format=YMD,display=Occurrence Date"`
}

// Order Sequence
type CM_OSD struct {
	HL7                               HL7Name `hl7:",name=CM_OSD,len=0,type=d"`
	SequenceResultsFlag               ID      `hl7:"1,display=S for sequence conditions; R is reserved for possible future use. "`
	PlacerOrderNumberEntityIdentifier ST      `hl7:"2,required,display=Uses two subcomponents since the placer order number has two components"`
	PlacerOrderNumberNamespaceID      IS      `hl7:"3,display=Uses two subcomponents since the placer order number has two components"`
	FillerOrderNumberEntityIdentifier ST      `hl7:"4,required,display=Uses two subcomponents since the filler order number has two components"`
	FillerOrderNumberNamespaceID      IS      `hl7:"5,display=Uses two subcomponents since the filler order number has two components"`
	SequenceConditionValue            ST      `hl7:"6,display=The acceptable condition values have the form commonly used in project planning methodologies  <one of 'SS'- 'EE'- 'SE'- or 'ES'> +/- <time>  The first letter stands for start (S) or end (E) of predecessor order- where the predecessor is defined by the placer or filler order number in subcomponents 1-2 or subcomponents 3-4.    The second letter stands for the start (S) or end (E) of the successor order- where the successor order is the order containing this quantity/timing specification.    The time specifies the interval between the predecessor and successor starts or ends "`
	MaximumNumberOfRepeats            NM      `hl7:"7,display=The maximum number of repeats to be used only on cyclic groups.  The total number of repeats is constrained by the end date/time of the last repeat or the end date/time of the parent- whichever is first."`
}

// Occurence Span
type CM_OSP struct {
	HL7                     HL7Name `hl7:",name=CM_OSP,len=0,type=d"`
	OccurrenceSpanCode      ID      `hl7:"1,display=Occurrence Span Code"`
	OccurrenceSpanStartDate DT      `hl7:"2,format=YMD,display=Occurrence Span Start Date"`
	OccurrenceSpanStopDate  DT      `hl7:"3,format=YMD,display=Occurrence Span Stop Date"`
}

// Patient Id
type CM_PAT_ID struct {
	HL7              HL7Name `hl7:",name=CM_PAT_ID,len=0,type=d"`
	PatientID        ST      `hl7:"1,display=Patient Id"`
	CheckDigit       NM      `hl7:"2,display=Check Digit"`
	CheckDigitScheme ID      `hl7:"3,table=0061,display=Check Digit Scheme"`
	FacilityID       ID      `hl7:"4,display=Facility Id"`
	Type             ID      `hl7:"5,display=Type"`
}

// Patient Id With Table 0192
type CM_PAT_ID_0192 struct {
	HL7              HL7Name `hl7:",name=CM_PAT_ID_0192,len=0,type=d"`
	PatientID        ST      `hl7:"1,display=Patient Id"`
	CheckDigit       NM      `hl7:"2,display=Check Digit"`
	CheckDigitScheme ID      `hl7:"3,table=0061,display=Check Digit Scheme"`
	FacilityID       ID      `hl7:"4,display=Facility Id"`
	Type             ID      `hl7:"5,table=0192,display=Type"`
}

// Pre-certification Required
type CM_PCF struct {
	HL7                         HL7Name `hl7:",name=CM_PCF,len=0,type=d"`
	PreCertificationPatientType ID      `hl7:"1,table=0150,display=Pre-certification Patient Type"`
	PreCerticationRequired      ID      `hl7:"2,table=0136,display=Pre-certication Required"`
	PreCertificationWindow      TS      `hl7:"3,format=YMDHMS,display=Pre-certification Window"`
}

// Penalty
type CM_PEN struct {
	HL7           HL7Name `hl7:",name=CM_PEN,len=0,type=d"`
	PenaltyID     ID      `hl7:"1,table=0148,display=Penalty Id"`
	PenaltyAmount NM      `hl7:"2,display=Penalty Amount"`
}

// Order Number Of The Client / The Contracting Authority
type CM_PLACER struct {
	HL7               HL7Name `hl7:",name=CM_PLACER,len=0,type=d"`
	UniquePlacerID    ST      `hl7:"1,len=15,display=The first component is a string of up to 15 characters that identifies an individual order (e.g.- OBR).  It is assigned by the placer (ordering application).  It identifies an order uniquely among all orders from a particular ordering application."`
	PlacerApplication ID      `hl7:"2,display=The second component contains the application ID of the placing application.  The application ID is a string of up to six (6) characters that will be uniquely associated with an application.  A given institution or group of intercommunicating institutions should establish a unique list of applications that may be potential placers and fillers and assign unique application ID's."`
}

// Action Carried Out By
type CM_PRACTITIONER struct {
	HL7                       HL7Name    `hl7:",name=CM_PRACTITIONER,len=0,type=d"`
	ProcedurePractitionerID   *CN_PERSON `hl7:"1,display=Procedure Practitioner  Id"`
	ProcedurePractitionerType ID         `hl7:"2,display=Procedure Practitioner Type"`
}

// Parent Result Link
//
// The third component may be used to record the name of the microorganism identified by the parent result directly.  The organism
// in this case should be identified exactly as it is in the parent culture
type CM_PRL struct {
	HL7                                     HL7Name `hl7:",name=CM_PRL,len=0,type=d"`
	OBX3ObservationIdentifierOfParentResult ST      `hl7:"1,display=OBX-3-observation identifier of parent result"`
	OBX4SubIDOfParentResult                 ST      `hl7:"2,display=OBX-4-sub-ID of parent result"`
	OBX5ObservationResultsFromParent        *CE     `hl7:"3,display=OBX-5-observation results from parent"`
}

// Policy Type
type CM_PTA struct {
	HL7         HL7Name `hl7:",name=CM_PTA,len=0,type=d"`
	PolicyType  ID      `hl7:"1,table=0147,display=Policy Type"`
	AmountClass ID      `hl7:"2,table=0193,display=Amount Class"`
	Amount      NM      `hl7:"3,display=Amount"`
}

// Interval
type CM_RI struct {
	HL7                  HL7Name `hl7:",name=CM_RI,len=0,type=d"`
	RepeatPattern        ST      `hl7:"1,display=Repeat Pattern"`
	ExplicitTimeIntevall ST      `hl7:"2,display=explicitly lists the actual times referenced by the code in the first subcomponent- in the following format: HHMM-HHMM-HHMM-...  This second subcomponent will be used to clarify the first subcomponent in cases where the actual administration times vary within an institution.  If the time of the order spans more than a single day- this new subcomponent is only practical if the same times of administration occur for each day of the order.  If the actual start time of the order (as given by the fourth subcomponent of the quantity/timing field) is after the first explicit time- the first administration is taken to be the first explicit time after the start time.  In the case where the patient moves to a location having a different set of explicit times- the existing order may be updated with a new quantity/timing field showing the changed explicit times"`
}

// Room Coverage
type CM_RMC struct {
	HL7            HL7Name `hl7:",name=CM_RMC,len=0,type=d"`
	RoomType       ID      `hl7:"1,table=0145,display=Room Type"`
	AmountType     ID      `hl7:"2,table=0146,display=Amount Type"`
	CoverageAmount NM      `hl7:"3,display=Coverage Amount"`
}

// Specimen Source
type CM_SPS struct {
	HL7                      HL7Name `hl7:",name=CM_SPS,len=0,type=d"`
	SpecimenSourceNameOrCode *CE     `hl7:"1,display=The first component contains the specimen source name or code (as a CE data type component).  (Even in the case of observations whose name implies the source- a source may be required- e.g.- blood culture-heart blood.) "`
	Additives                TX      `hl7:"2,display=The second component should include additives to the specimen such as Heparin- EDTA- or Oxlate- when applicable."`
	Freetext                 TX      `hl7:"3,display=The third is a free text component describing the method of collection when that information is a part of the order.  When the method of collection is logically an observation result- it should be included as a result segment."`
	BodySite                 *CE     `hl7:"4,table=0070,display=The fourth component specifies the body site from which the specimen was obtained- and the fifth is the site modifier.  For example- the site could be anticubital foss- and the site modifier 'right.'   The components of the CE data elements become subcomponents.  Refer to table 0070 - source of specimen for valid entries"`
	SiteModifier             *CE     `hl7:"5,display=Site Modifier"`
}

// Value Code And Amount
type CM_UVC struct {
	HL7         HL7Name `hl7:",name=CM_UVC,len=0,type=d"`
	ValueCode   ID      `hl7:"1,table=0153,display=Value Code"`
	ValueAmount NM      `hl7:"2,display=Value Amount"`
}

// Value Qualifier
type CM_VR struct {
	HL7                HL7Name `hl7:",name=CM_VR,len=0,type=d"`
	FirstDataCodeValue ST      `hl7:"1,display=First Data Code Value"`
	LastDataCodeCalue  ST      `hl7:"2,display=Last Data Code Calue"`
}

// Cn For Person
//
// A field identifying a person both as a coded value and with a text name.  The first component is the coded ID according to a site-specific
// table.  The second through the seventh  components are the person's name as a PN field.  The eighth component specifies the
// source table used for the first component.  For specific fields, individual sites may elect to omit the ID or the name.
//
// Example:
// |12372^RIGGINS^JOHN^""^""^""^MD^ADT1| |12372| |^RIGGINS^JOHN^""^""^""^MD|
type CN_PERSON struct {
	HL7                 HL7Name `hl7:",name=CN_PERSON,len=0,type=d"`
	IDNumber            ID      `hl7:"1,display=Id Number"`
	FamiliyName         ST      `hl7:"2,display=Familiy Name"`
	GivenName           ST      `hl7:"3,display=Given Name"`
	MiddleInitialOrName ST      `hl7:"4,display=Middle Initial Or Name"`
	Suffix              ST      `hl7:"5,display=Suffix (e.g. Jr Or Iii)"`
	Prefix              ST      `hl7:"6,display=Prefix (e.g. Dr)"`
	Degree              ST      `hl7:"7,display=Degree (e.g. Md)"`
	SourceTableID       ID      `hl7:"8,display=Source Table Id"`
}

// Cn For Physicians
type CN_PHYSICIAN struct {
	HL7                 HL7Name `hl7:",name=CN_PHYSICIAN,len=0,type=d"`
	PhysicianID         ID      `hl7:"1,display=Physician Id"`
	FamiliyName         ST      `hl7:"2,display=Familiy Name"`
	GivenName           ST      `hl7:"3,display=Given Name"`
	MiddleInitialOrName ST      `hl7:"4,display=Middle Initial Or Name"`
	Suffix              ST      `hl7:"5,display=Suffix (e.g. Jr Or Iii)"`
	Prefix              ST      `hl7:"6,display=Prefix (e.g. Dr)"`
	Degree              ST      `hl7:"7,display=Degree (e.g. Md)"`
	SourceTableID       ID      `hl7:"8,display=Source Table Id"`
}

// Composite Id W/chk Digit
type COMP_ID_DIGIT = string

// Composite Quantity With Units
//
// Quantity of the service that should be provided at each service interval.  E.g, if two blood cultures to be obtained every
// 4 hours, the quantity would be 2.  If three units of blood are to be typed and cross-matched, the quantity would be 3.  The default
// value is 1.  When units are required, they can be added, specified by a subcomponent delimiter.
//
// In future versions, CQ fields should be avoided because the same data can usually be sent as two separate fields, one with
// the value and one with the units as a CE data type
//
// Examples:
//
// |123.7^kg|  kilograms is an ISO unit
// |150^lb&&ANSI+| weight in pounds is a customary US unit defined within ANSI+
type CQ struct {
	HL7      HL7Name `hl7:",name=CQ,len=0,type=d"`
	Quantity NM      `hl7:"1,display=Quantity"`
	Units    ST      `hl7:"2,display=The units in which the quantity is expressed.  Field-by-field- default units may be defined within the specifications.  When the observation is measured in the default units- the units need not be transmitted.  If the measure is recorded in units different from the default- the measurement units must be transmitted as the second component.  If the units are ISO+ units- then units should be recorded as lowercase abbreviations as specified in Chapter 7.  If the units are ANSI or local- the units and the source table must be recorded as specified in Chapter 7.  But in these cases the component separator should be replaced by the subcomponent delimiter "`
}

// Date
//
// Always in the format YYYYMMDD.
//
// Example:
// |19880704|
type DT = time.Time

// Formatted Text Data
//
// This data type is derived from the  string data type by allowing the addition of  embedded formatting instructions.  These
// instructions are limited to those that are intrinsic and independent of the circumstances under which the field is being
// used.  The actual instructions and their representation are described later in this chapter.  The differences from a string
// data field and an FT field is of arbitrary length (up to 65k) and may contain formatting commands enclosed in escape characters.
//
// Example:
// |\.sp\(skip one vertical line)|
type FT = string

// Hierarchic Designator
//
// The HD is designed to be a more powerful application identifier.  It is also designed to be used either as a local version of
// a site-defined application identifier or a publicly-assigned UID.  Syntactically, the HD is a group of two application
// identifiers: one defined by the first component, and one defined by the second and third components.
//
// The HD allows any site to act as an assigning authority (on a local or user-defined basis), even if it technically does not
// have the right to issue new IDs within an identification scheme.  HDs which have defined third components (defined UID types)
// must be unique within the series of ID’s defined by that component.
type HD struct {
	HL7             HL7Name `hl7:",name=HD,len=0,type=d"`
	NamespaceID     IS      `hl7:"1,display=Refer to user-defined table 0300 - Namespace ID for suggested values"`
	UniversalID     ST      `hl7:"2,display=The HD’s second component- Universal ID (UID)- is a string formatted according to the scheme defined by the third component- Universal ID type (UID type).  The UID is intended to be unique over time within the UID type.  It is rigorously defined.  Each UID must belong  to one of the specifically enumerated schemes for constructing UID’s (defined by the UID type).  The UID (second component) must follow the syntactic rules of the particular universal identifier scheme (defined by the third component). "`
	UniversalIDType ID      `hl7:"3,display=The third component governs the interpretation of the second component of the HD.  If the third component is a known UID refer to HL7 table 0301 - Universal ID type for valid values- then the second component is a universal ID of that type"`
}

// Coded Value
type ID = string

// Coded value for user-defined tables
//
// The value of such a field follows the formatting rules for an ST field except that it is drawn from a sitedefined (or user-defined)
// table of legal values.  There shall be an HL7 table number associated with IS data types.  An example of an IS field is the Event
// reason code defined in Section 3.3.1.4, “Event reason code.” This data type should be used only for user-defined tables
// (see Section 2.6.7, “ID number”).  The reverse is not true, since in some circumstances, it is more appropriate to use the
// CE data type for user-defined tables
type IS = string

// Numeric
//
// A number represented as a series of ASCII numeric characters consisting of an optional leading sign (+ or -), the digits
// and an optional decimal point.  In the absence of a sign, the number is assumed to be positive.  If there is no decimal point
// the number is assumed to be an integer.
//
// Examples:
// |999|
// |-123.792|
type NM = string

// Person Location
//
// This data type is used to specify a patient location within a healthcare institution. Which components are valued depends
// on the needs of the site.  It is most commonly used for specifying patient locations, but may refer to other types of persons
// within a healthcare setting.
type PL struct {
	HL7                HL7Name `hl7:",name=PL,len=0,type=d"`
	PointOfCare        ID      `hl7:"1,display=Conditional on person location type (e.g.- nursing unit or department or clinic).  After floor- most general patient location designation.  Refer to user-defined table 0302 - Point of care for suggested values."`
	Room               IS      `hl7:"2,display=Patient room.  After nursing unit- most general person location designation.  Refer to user-defined table 0303 - Room for suggested values"`
	Bed                IS      `hl7:"3,display=Patient bed.  After room- most general person location designation.  Refer to user-defined table 0304 - Bed for suggested values"`
	Facility           *HD     `hl7:"4,display=Most general person location designation. (See Section 2.8.18- “HD - hierarchic designator”). "`
	LocationStatus     IS      `hl7:"5,display=Location (e.g.- Bed) status.  Refer to user-defined table 0306 - Location status for suggested values"`
	PersonLocationType IS      `hl7:"6,display=Usually includes values such as nursing unit- department- clinic- SNF- physician’s office.  Refer to userdefined table 0305 - Person location type for suggested values"`
	Building           IS      `hl7:"7,display=After facility- most general person location designation.  Refer to user-defined table 0307 - Building for suggested values"`
	Floor              ST      `hl7:"8,display=After building- most general person location designation.  Refer to user-defined table 0308 - Floor for suggested values"`
	LocationType       ST      `hl7:"9,display=A free text description of the location"`
}

// Person Name
//
// A name includes multiple free text components as listed above.  The maximum length of a PN field is 48 characters including
// component separators.  The sending system may send upper- and lowercase or all uppercase.  The receiving system may convert
// to all uppercase if required.
//
// Example:
// |SMITH^JOHN^J^III^DR^PHD|
type PN struct {
	HL7                 HL7Name `hl7:",name=PN,len=0,type=d"`
	FamiliyName         ST      `hl7:"1,display=Familiy Name"`
	GivenName           ST      `hl7:"2,display=Given Name"`
	MiddleInitialOrName ST      `hl7:"3,display=Middle Initial Or Name"`
	Suffix              ST      `hl7:"4,display=Suffix (e.g. Jr Or Iii)"`
	Prefix              ST      `hl7:"5,display=Prefix (e.g. Dr)"`
	Degree              ST      `hl7:"6,display=Degree (e.g. Md)"`
}

// Sequence Id
//
// A positive integer in the form of an NM field.  The uses of this field are defined in the chapters defining the segments and
// messages in which it appears.
type SI = string

// String Data
//
// String data is left justified with trailing blanks optional.  Any displayable (printable) ACSII characters (hexadecimal
// values between 20 and 7E, inclusive).
//
// Example:
// |almost any data at all|
type ST = string

// Telephone Number
//
// For use in the United States and conforming countries, the telephone number is always in the form: [NN] [(999)]999-9999[X99999][B99999][C
// any text]
//
// Examples:
// |(415)925-0121X305| |234-4532CWEEKENDS|
type TN = string

// Timing Quantity
//
// Quantity/timing (ORC-7, OBR-27) provides a means of specifying when the service described by the order segment is to be
// performed and how frequently.  It is a complex multicomponent field that can have repeats; i.e., more than one quantity/timing
// specification, separated by repeat delimiters, may appear.  It is a distinct data type (see section 2.4.5.20).
type TQ struct {
	HL7             HL7Name `hl7:",name=TQ,len=0,type=d"`
	Quantity        *CQ     `hl7:"1,display=quantity of the service that should be provided at each service interval.  E.g- if two blood cultures to be obtained every 4 hours- the quantity would be 2.  If three units of blood are to be typed and cross-matched- the quantity would be 3.  The default value is 1.  When units are required- they can be added- specified by a subcomponent delimiter"`
	Interval        *CM_RI  `hl7:"2,display=determines the interval between repeated services."`
	Duration        ST      `hl7:"3,display=Indicates how long the service should continue after it is started.  The default is INDEF (do indefinitely)."`
	StartDateTime   TS      `hl7:"4,format=YMDHMS,display=May be specified by the orderer- in which case it indicates the earliest date/time at which the services should be started.  In many cases- however- the start date time will be implied or will be defined by other fields in the order record (e.g.- urgency - STAT).  In such a case- this field will be empty"`
	EndDateTime     TS      `hl7:"5,format=YMDHMS,display=when filled in by the requester of the service- this field should be the latest date-time that the service should be performed.  If it has not been performed by the specified time- it should not be performed at all.  The requester may not always fill in this value- yet the filling service may fill it in on the basis of the instruction it receives and the actual start time."`
	Priority        ID      `hl7:"6,display=describes the urgency of the request.  The following values are suggested (the default for Priority is R)"`
	Condition       ST      `hl7:"7,display=This is a free text field that describes the conditions under which the drug is to be given.  For example- PRN pain- or to keep blood pressure below 110.  The presence of text in this field should be taken to mean that human review is needed to determine the how and/or when this drug should be given"`
	Text            TX      `hl7:"8,display=full text version of the instruction (optional)."`
	Conjunction     ID      `hl7:"9,display= non-null component indicates that a second timing specification is to follow using the repeat delimiter.  This field can take three values:   S :  Synchronous  A :  Asynchronous  C :  This is an actuation time "`
	OrderSequencing *CM_OSD `hl7:"10,display=there are many situations- such as the creation of an order for a group of intervenous (IV) solutions- where the sequence of the individual intervenous solutions (each an order in itself) needs to be specified.  There are other situations- where part of the order's instructions contains a results condition of some type- such as 'PRN pain.'  There is currently a free text 'condition' component of ORC-4-quantity/timing which allows any condition to be specified.  However- to support a fully encoded version of order sequencing- or results condition- we have defined in the following paragraphs a 10th component of ORC-4quantity/timing"`
}

// Time Stamp
//
// Contains the exact time of an event, including the date and time.  Time stamp fields are always in the format:
//
// YYYYMMDD[HHMM[SS[.SSSS]]][+/-ZZZZ]^<degree of precision>
//
// The date portion of a time stamp follows the rules of a date field and the time portion follows the rules of a time field.  When
// used as a birthdate, the HHMM portion is optional.  If not present the HHMM portion will default to 0000, i.e., midnight of
// the day just beginning.  The specific data representations used in the HL7 encoding rules are compatible with ISO 8824-1987(E).
// An optional second component indicates the degree of precision of the date (Y = year, L = month, D = day, H = hour, M = minute,
// S = second). (Maximum length of field is 26).
//
// Examples:
//
// |17760704010159-0600|1:01:59 on July 4, 1776 in the Eastern Standard Time zone.
//
// |17760704010159-0500|1:01:59 on July 4, 1776 in the Eastern Daylight Saving Time zone.
//
// |198807050000|  Midnight of the night extending from July 4 to July 5, 1988 in the local time zone of the sender.
//
// |198807050000^D| Same as prior example, but precision extends only to the day.  Could be used for a birthdate.
type TS = time.Time

// Text Data
//
// String data meant for user display (on a terminal or printer).  Such data would not necessarily be left justified since leading
// spaces may contribute greatly to the clarity of the presentation to the user.  Because this type of data is intended for display,
// it may contain certain escape character sequences designed to control the display.  Escape sequence formatting is defined
// later in this chapter in Section 2.4.6.  Leading spaces should be included.  Trailing spaces should be removed.
//
// Example:
// |  leading spaces are allowed.|
type TX = string

// Variable Datatype
type VARIES any
